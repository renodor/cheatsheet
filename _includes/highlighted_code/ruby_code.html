{% capture freezeConstant %}
# If we freeze an Array:
NUMBERS = [1, 2, 3, 4].freeze

# And then try to add a new value to this Array
NUMBERS << 5

# We will outputs: FrozenError: can't modify frozen Array
{% endcapture %}

{% capture method %}
# method definition:
def add_five(number)
  number + 5
end

# calling the method:
add_five(5)
# >> will return 10
{% endcapture %}

{% capture dangerousMethods %}
username = 'renodor'
username.capitalize # outputs 'Renodor', but username's value is still 'renodor':
puts username # outputs 'renodor'

# whereas:
username.capitalize! # outputs 'Renodor', and username's value is now 'Renodor':
puts username # outputs 'Renodor'
{% endcapture %}

{% capture methodWithoutParenthesis %}
def add_five number
  number + 5
end
{% endcapture %}

{% capture methodWithMultipleParameters %}
def add_values(a, b)
  a + b
end
{% endcapture %}

{% capture methodWithDefaultParameters %}
def add_values(a = 1, b = 2, c)
  a + b + c
end
{% endcapture %}

{% capture ifConditions %}
if condition
  # code to execute
end

if condition
  # code to execute
else
  # code to execute
end

if condition
  # code to execute
elsif other_condition
  # code to execute
else
  # code to execute
end

# Simpler form for one line statements:
code_to_execute if condition
{% endcapture %}

{% capture UnlessConditions %}
unless condition
 # code to execute
end

# Simpler form for one line statements:
code_to_execute unless condition
# (This is the same as: code_to_execute if !condition)
{% endcapture %}

{% capture caseStatement %}
age = 50
case age
when 0
  p "you're not born yet little man"
when 10
  p "time to have fun"
when 18
  p "time to have more fun"
when 30
  p "time to have fun again"
when 50
  p "yep, still fun"
when 100
  p "probably a lot of fun too"
else
  p "it's not worth it"
end
{% endcapture %}

{% capture ternary %}
condition ? 'I will be executed if its true' : 'I will be executed if its false'
{% endcapture %}

{% capture andStatement %}
if condition && other_condition
  # will be executed if BOTH conditions are true
end
{% endcapture %}

{% capture orStatement %}
if condition || other_condition
  # will be executed if AT LEAST one of the two conditions is true
end
{% endcapture %}

{% capture truthTable %}
true  && true   #=> true
false && false  #=> false
true  && false  #=> false

true  || true   #=> true
false || false  #=> false
true  || false  #=> true
{% endcapture %}

{% capture finishedLoop %}
10.times do
  # code
end
# will execute the code 10 times

# you can also pass an argument to the times function:
10.times do |n|
  puts "#{n} - I am repeating myself"
end
# will ouputs:
# 1 - I am repeating myself
# 2 - I am repeating myself
# 3 - I am repeating myself
# etc...
{% endcapture %}

{% capture whileLoop %}
while condition
  # code
end
# will stop the loop only when the condition is FALSE
{% endcapture %}

{% capture untilLoop %}
until condition
  # code
end
# will stop the loop only when the condition is TRUE
{% endcapture %}

{% capture forLoop %}
for num in [1, 2, 3]
  puts num
end
# will outputs:
# 1
# 2
# 3
{% endcapture %}

{% capture eachFunction %}
[1, 2, 3].each do |num|
  puts num
end
{% endcapture %}

{% capture exitLoop %}
def my_loop
  (1..100).to_a.shuffle.each do |num| # will iterate over numbers from 1 to 100 in a random order
    next if num.odd? # will skip iteration if current number is odd
    break if num > 50 # will break from the loop if current number is higher than 50
    return num if num == 98 # will stop the loop and exist the method returning current number if its 98
  end
end
{% endcapture %}

{% capture join %}
[1, 2, 3].join # will outputs "123"
[1, 2, 3].join(' ') # will outputs "1 2 3"
[1, 2, 3].join('-') # will outputs "1-2-3"
{% endcapture %}

{% capture split %}
'I am a sentence'.split # will outputs ["I", "am", "a", "sentence"]
'abcd'.split('') # will outputs ["a", "b", "c", "d"]
'Hey, hi Mark!'.split(',') # will outputs ["Hey", " hi Mark!"]
{% endcapture %}

{% capture count %}
arr = [1, 2, 2, 3, 4]
arr.count # will outputs 5
arr.count(2) # will outputs 2
arr.count { |num| num > 3 } # will outputs 1
{% endcapture %}

{% capture block_one_line %}
{ |num| num * 10 }

# as in:
arr.each { |num| num * 10 }
{% endcapture %}

{% capture block_multi_line %}
do |num|
  num * 10
end

# as in:
arr.each do |num|
  num * 10
end
{% endcapture %}

{% capture yield %}
# method definition
def strange_greetings
  p 'Hello'
  yield
  p 'Aaaaaand its over.'
end

# method calling
strange_greetings do
  p 'I am strange,'
  p 'but its cool right?'
end

# This will outputs in this order:
# "Hello"
# "I am strange,"
# "but its cool right?"
# "Aaaaaand its over."
{% endcapture %}

{% capture hash %}
# define an empty hash:
panama = {}

# add new key/value pairs to my hash:
panama['population'] = 4170607
panama['type'] = 'tropical'

# now my hash has two key/value pairs:
panama = {
  "population" => 4170607,
  "type" = "tropical"
}
{% endcapture %}

{% capture hash_with_symbols %}
my_hash = { 'name' => 'Bob', 'surname' => 'Marley', 'speciality' => 'Reggae' }

# If we use symbols for keys:
my_hash = { :name => 'Bob', :surname => 'Marley', :speciality => 'Reggae' }

# Which can be shortened like that:
my_hash = { name: 'Bob', surname: 'Marley', speciality: 'Reggae' }
{% endcapture %}

{% capture each %}
[1, 2, 3].each do |num|
  puts num
end
# will outputs:
# 1
# 2
# 3
{% endcapture %}

{% capture each_hash %}
my_hash = { name: 'Bob', surname: 'Marley', speciality: 'Reggae' }
my_hash.each do |key, value|
  puts "#{key}: #{value}"
end

# will outputs:
# name: Bob
# surname: Marley
# speciality: Reggae
{% endcapture %}

{% capture each_with_index %}
['hello', 'bonjour', 'hola'].each_with_index do |word, i|
  puts "#{i}- #{word}"
end
# will outputs:
# 0- hello
# 1- bonjour
# 2- hola
{% endcapture %}

{% capture map %}
new_arr = [1, 2, 3].map do |num|
  num * 10
end

p new_arr # will outputs [10, 20 30]
{% endcapture %}
{% capture select %}
new_array = [0, 1, 2, 3, 4, 5, 6].select do |num|
  num.even?
end

p new_array # will outputs [0, 2, 4, 6]
{% endcapture %}

{% capture reject %}
new_array = [0, 1, 2, 3, 4, 5, 6].reject do |num|
  num.even?
end

p new_array # will outputs [1, 3, 5]
{% endcapture %}

{% capture regex-condition %}
if /b/ =~ 'abcd'
  p 'Yeah!'
else
  p 'oh no...'
end

if /b/.match?('abcd')
  p 'Yeah!'
else
  p 'oh no...'
end
{% endcapture %}

{% capture regex-match-data %}
# I create a Regex looking for 'abc', and putting it in three different groups
regex = /(a)(b)(c)/

match_data_result = regex.match('abc')
# Now my variable match_data_result contains a MatchData object that looks like that:
# <MatchData "abc" 1:"a" 2:"b" 3:"c">

# So I can get the different regex groups:
match_data_result[0] # will return "abc" (the whole match)
match_data_result[1] # will return "a" (the first group)
match_data_result[2] # will return "b" (the second group)
match_data_result[3] # will return "c" (the third group)
{% endcapture %}

{% capture regex-match-data-named-groups %}
# I create a Regex looking for:
# - one or more of any word characters (and I name this group "first_name")
# - a ":"
# - one or more of any word characters (and I name this group "last_name")
regex = /(?<first_name>\w+):(?<last_name>\w+)/

# I create my MatchData object
match_data_result = regex.match('Bruce:Wayne')

# I can now call the different groups by their name on my MatchData:
match_data_result[:first_name] # will return "Bruce" (match_data_result['first_name'] works too)
match_data_result[:last_name] # will return "Wayne" (and match_data_result['last_name'] works too)
{% endcapture %}

{% capture regex-scan %}
'abab'.match(/a|b/) # will return a MatchData with only one match: "a"
'abab'.scan(/a|b/) # will return an array with: ["a", "b", "a", "b"]
'abab'.scan(/(a|b)/) # will return an array with: [["a"], ["b"], ["a"], ["b"]]
{% endcapture %}

{% capture regex-gsub %}
'renodor'.gsub('o', '*') # will return 'ren*d*r'
'renodor'.gsub(/o|e/, '*') # will return 'r*n*d*r'

# You can also capture groups in your regex and reuse it:
'renodor'.gsub(/(o|e)/, '~\1~') # will return 'r~e~n~o~d~o~r':
# Indeed, I created a regex that look for 'e' or 'o' and put it in a group
# In the second argument of gsub, \1 refers to my group.
# so '~\1~' means "when you find my group, put a ~ before and after it"

# You can also use named groups, and then call them with the \k<group_name> notation:
'renodor'.gsub(/(?<my_group>o|e)/, '-\k<my_group>-') # will return 'r-e-n-o-d-o-r'
{% endcapture %}


{% capture parse_csv %}
require 'csv'

file_path = 'path/to/file.csv'

CSV.foreach(file_path) do |row|
  p row[0]
end
# For each row of the file, it will output the value of the first column

CSV.foreach(file_path) do |row|
  p "#{row[0]} | #{row[1]} | #{row[2]}"
end
# For each row of the file, it will output the value of the first 3 columns separated by pipes
{% endcapture %}

{% capture csv_options %}
require 'csv'

file_path = 'path/to/file.csv'
csv_options = { col_sep: ',', quote_char: '"', headers: :first_row }
# We precise that it's a comma separated csv, strings are double quoted, and the first row is the header
# (so that the header won't be returned when using csv.foreach)

CSV.foreach(file_path, csv_options) do |row|
  p row['column_name'] # and now we can use the column name instead of its index
end
{% endcapture %}

{% capture store_csv %}
require 'csv'

file_path = 'path/to/file.csv'
csv_options = { col_sep: ',', force_quotes: true, quote_char: '"' }

CSV.open(file_path, 'wb', csv_options) do |csv|
  csv << ['Name', 'Type', 'Origin']
  csv << ['Guinness', 'Stout', 'Ireland']
  # etc... line per line
end

# 'wb' means write. So the whole content of the csv file will be re-written by the method.
# you can also use 'a' instead, that means 'append', so the method will add the content at the end of the csv file:

CSV.open(file_path, 'a', csv_options) do |csv|
  # code
end
{% endcapture %}

{% capture parse_json %}
require 'json'

file_path = 'path/to/file.json'
serialized_file = File.read(file_path) # We use the File class to read the JSON file and transform it to a string
JSON.parse(serialized_file) # Returns a Hash containing the JSON file data
{% endcapture %}

{% capture parse_json_from_web %}
require 'json'
require 'open-uri' # allow to open URLs in ruby

url = 'https://my-api-endpoint'
serialized_data = open(url).read
JSON.parse(serialized_data) # Returns a Hash containing the JSON data from the url
{% endcapture %}

{% capture store_json %}
require 'json'

# We create a Hash with data we want to store:
data = { 'name': 'Batman', 'identity': 'Bruce Wayne', 'power': 'Rich' }

file_path = 'path/to/file.json'
File.open(file_path, 'wb') do |file|
  file.write(JSON.generate(data))
end
{% endcapture %}

{% capture scrapping %}
require 'open-uri'
require 'nokogiri'

url = "https://www.url-to-scrap"

html_file = open(url).read
html_doc = Nokogiri::HTML(html_file) # will create a "nokogiri" document you can manipulate (and call .search on it)

css_selector = '.class-name' # this is the CSS selector you will use on the HTML document to find the specific elements you are looking for
html_doc.search(css_selector).each do |element|
  puts element
end
{% endcapture %}